1. Используем USART3. Замыкаем RX-TX.
2. Прием: периферийные инициализации, включая инициализации периферийных прерываний NVIC (создает CubeMX) -> запуск процесса генерации прерывания по окончанию HAL_UART_Receive_IT (вернет HAL_OK/HAL_ERROR/HAL_BUSY) -> прерывание USART3_IRQHandler (создает CubeMX stm32f4xx_it.c) -> старт обработчика HAL_UART_IRQHandler (создает CubeMX в stm32f4xx_hal_uart.c), который в зависимости от результата выдаст Callback HAL_UART_RxCpltCallback/HAL_UART_ErrorCallback, которые можно переопределить.
3. Передача: периферийные инициализации, включая инициализации периферийных прерываний NVIC (создает CubeMX) -> запуск процесса генерации прерывания по окончанию HAL_UART_Transmit_IT (вернет HAL_OK/HAL_ERROR/HAL_BUSY) -> прерывание USART3_IRQHandler (создает CubeMX в stm32f4xx_it.c) -> старт обработчика HAL_UART_IRQHandler (создает CubeMX в stm32f4xx_hal_uart.c), который в зависимости от результата выдаст Callback HAL_UART_TxCpltCallback/HAL_UART_ErrorCallback которые можно переопределить.
4. Передача буфера через UART неблокирующая функция, программа может продолжаться.
5. Прерывание USART3_IRQHandler означает, что регистр данных пуст, мы можем отправить больше данных или обнаружена ошибка.
6. В HAL_UART_IRQHandler передается информация о прерывании процесса. Отправить больше данных, если буфер не пуст.
7. Если буфер данных пуст, используейте Callback функцию завершения HAL_UART_TxCpltCallback. Или, если была обнаружена ошибка, используйте функцию обратного вызова Error HAL_UART_ErrorCallback.
8. Алгоритм: инициализация USART -> USART отправляет буфер -> вызывается прерывание USART1_IRQHandler, когда регистр USART_TX пуст -> отправить еще данные/обработка ошибки -> буфер отправлен, конец процесса, вызов HAL_UART_TxCpltCallback / передача с ошибкой, вызов HAL_UART_ErrorCallback.
9. Прием завершен успешно - горит LED3, передача завершена успешно - горит LED4.